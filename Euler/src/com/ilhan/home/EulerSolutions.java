package com.ilhan.home;

import java.util.ArrayList;

public class EulerSolutions {
	/*
	If we list all the natural numbers below 10 that are multiples of 3 or 5,
	we get 3, 5, 6 and 9. The sum of these multiples is 23.
	Find the sum of all the multiples of 3 or 5 below 1000.
	*/
	
	private long startTime;
	private long stopTime;
	private void StartTimer(){
		startTime = System.currentTimeMillis();
	}
	private void StopTimer(int number){
		stopTime = System.currentTimeMillis();
		System.out.println("Elapsed Time For Question " + String.valueOf(number) + " : "  + String.valueOf(stopTime-startTime) + " ms");
	}
	private void PrintAnswer(int number, int result){
		System.out.println("The Answer for Question " + String.valueOf(number) + " is " + String.valueOf(result));
	}
	private void PrintAnswer(int number, long result){
		System.out.println("The Answer for Question " + String.valueOf(number) + " is " + String.valueOf(result));
	}
	
	
	public int Euler1(){
		StartTimer();
		int sum = 0;
		int i;
		for(i=3; i<1000; i=i+3){
			sum += i;
		}
		for(i=5; i<1000; i=i+5){
			sum += i;
		}
		for(i=15; i<1000; i=i+15){
			sum -= i;
		}
		PrintAnswer(1,sum);
		StopTimer(1);
		return sum;
	}
	
	/* 
	Each new term in the Fibonacci sequence is generated by adding the 
	previous two terms. By starting with 1 and 2, the first 10 terms will be:
	1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
	By considering the terms in the Fibonacci sequence whose values 
	do not exceed four million, find the sum of the even-valued terms.
	*/
	public long Euler2(){
		StartTimer();
		long sum = 0;
		int fiboCurrent = 1;
		int fiboPrev = 1;
		while(fiboCurrent < 4000000){
			fiboCurrent += fiboPrev;
			fiboPrev = fiboCurrent - fiboPrev;
			if(fiboCurrent%2 == 0){
				sum += fiboCurrent;
			}
		}
		PrintAnswer(2,sum);
		StopTimer(2);
		return sum;
	}
	
	private boolean IsPrime(long number){
		if(((number%2) == 0)){
			if(number==2){
				return true;
			}
			return false;
		}
		long sqrt = (long)Math.sqrt(number);
		for(long i=3; i<=sqrt; i+=2){
			if(number%i == 0){
				return false;
			}
		}
		return true;
	}
	
	private boolean IsPrimeRecursive(long number){
		if(((number%2) == 0) & (number != 2)){
			return false;
		}
		long sqrt = (long)Math.sqrt(number);
		for(long i=3; i<=sqrt; i+=2){
			if(IsPrime(i)){
				if((number%i) == 0){
					return false;
				}
			}
		}
		return true;
	}
	
	private ArrayList<Long> Dividers(long number){
		ArrayList<Long> dividerArray = new ArrayList<Long>();
		long sqrt = (long)Math.sqrt(number);
		while((number%2) == 0){
			dividerArray.add((long)2);
			number /= 2;
		}
		for(long dividerCandidate=3; dividerCandidate<=Math.min(sqrt, number); dividerCandidate+=2){
			while((number%dividerCandidate) == 0){
				dividerArray.add(dividerCandidate);
				number /= dividerCandidate;
			}
		}
		return dividerArray;
	}
	
	public long Euler3(){
		StartTimer();
		long number = 600851475143L;
		ArrayList<Long> dividers = Dividers(number);
		int numOfDividers = dividers.size();
		PrintAnswer(3, dividers.get(numOfDividers-1));
		StopTimer(3);
		return dividers.get(numOfDividers-1);
	}
	
	private int NumberOfDigits(int number){
		int digitNumber=1;
		while(true){
			if(number < Math.pow(10, digitNumber)){
				break;
			}
			digitNumber++;
		}
		return digitNumber;
	}
	
	private int ReverseNumber(int number){
		int numOfDigits = NumberOfDigits(number);
		int[] digitArray = new int[numOfDigits];
		int divider;
		for(int i=numOfDigits-1; i>=0; i--){
			divider = (int)Math.pow(10, i);
			digitArray[i] = number/divider;
			number %= divider;
		}
		int reversedNumber = 0;
		for(int i=0; i<numOfDigits; i++){
			reversedNumber += digitArray[numOfDigits-1-i]*Math.pow(10, i);
		}
		return reversedNumber;
	}
	
	private boolean IsPalindrome(int number){
		return number==ReverseNumber(number);
	}
	
	public int Euler4(){
		StartTimer();
		int max = 0;
		int product;
		for(int i=999; i>99; i--){
			for(int j=i; j>99; j--){
				product = i*j;
				if (product<max){
					break;
				}
				if(IsPalindrome(product)){
					max = product;
				}
			}
		}
		PrintAnswer(4, max);
		StopTimer(4);
		return max;
	}
	
	private int FindPowerLessThan(int base, int threshold){
		int power=1;
		while(true){
			if(Math.pow(base, power) > threshold){
				break;
			}
			power++;
		}
		return power-1;
	}
	
	public int Euler5(){
		StartTimer();
		int threshold = 20;
		int number = 1;
		number *= Math.pow(2, FindPowerLessThan(2, threshold));
		for(int prime=3; prime<threshold; prime+=2){
			if(IsPrime(prime)){
				number*= Math.pow(prime, FindPowerLessThan(prime, threshold));
			}
		}
		PrintAnswer(5, number);
		StopTimer(5);
		return number;
	}
	
	public int Euler6(){
		StartTimer();
		int sumOfSquares = (2*100+1)*(100+1)*100/6;		//(2n+1)(n+1)n/6 = sum(i^2) for i=1..n
		int sumOfNumbers = 100*101/2;					//n(n+1)/2 = sum(i) for i=1..n
		int difference = (int)(Math.pow(sumOfNumbers,2)-sumOfSquares);
		PrintAnswer(6,difference);
		StopTimer(6);
		return difference;
	}
	
	public int Euler7(){
		StartTimer();
		int i=3;
		int numOfPrimes = 1;
		while(true){
			if(IsPrime(i)){
				numOfPrimes++;
				if(numOfPrimes == 10001){
					break;
				}
			}
			i+=2;
		}
		PrintAnswer(7,i);
		StopTimer(7);
		return i;
	}
}
